
##2A 

1、您不能轻松地直接运行Raft实现；相反，您应该通过测试仪来运行它，即进行test-run 2A.

2、遵循本文的图2。此时，您将关心发送和接收RequestVote RPC，与选举有关的服务器规则以及与领导人选举有关的状态  

3、在raft.go中 的Raft结构中添加图2的领导者选举状态。您还需要定义一个结构来保存有关每个日志条目的信息

4、填写RequestVoteArgs和 RequestVoteReply结构。修改 Make（）以创建一个后台goroutine，
该后台goroutine将在有一段时间没有收到其他对等方的请求时通过发出RequestVote RPC来定期启动领导者选举。
这样，同伴将了解谁是领导者（如果已经有领导者），或者成为领导者本身。实现RequestVote（） RPC处理程序，
以便服务器相互投票

5、要实现心跳，请定义一个 AppendEntries RPC结构（尽管您可能还不需要所有参数），
并让领导者定期将其发送出去。编写一个 AppendEntries RPC处理程序方法，
该方法将重置选举超时，以便在已经选择一个服务器时，其他服务器不再作为领导者前进

6、确保不同对等方的选举超时不会总是同时触发，否则所有对等方都只会为自己投票，而没有人会成为领导者

7、测试人员要求领导者每秒发送的心跳RPC不超过十次

8、测试人员要求您的Raft在旧领导者失败的五秒钟内（如果大多数同龄人仍然可以沟通）选出一位新领导者。
但是请记住，如果出现分裂投票，则领导者选举可能需要进行多轮投票
（如果数据包丢失或候选人不幸地选择了相同的随机退避时间，则可能会发生这种情况）。
您必须选择足够短的选举超时（以及因此而产生的心跳间隔），即使需要进行多轮选举，
选举也很可能在不到五秒钟的时间内完成


9、论文的5.2节提到选举超时的范围是150到300毫秒。仅当领导者发送心跳的频率大大超过每150毫秒一次的频率时，
此范围才有意义。因为测试仪将您的心跳限制为每秒10个心跳，所以您必须使用大于纸张150到300毫秒的选举超时时间，
但不能太大，因为那样的话，您可能会在五秒钟内无法选举领导者

10、您可能会发现Go的 rand 非常有用

11、您需要编写定期或在时间延迟后执行操作的代码。最简单的方法是使用调用time.Sleep（）的循环创建一个goroutine 。
不要使用Go的time.Timer或time.Ticker，这是很难正确使用

12、阅读有关锁定https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt
和 结构 https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt 的建议

13、如果您的代码无法通过测试，请再次阅读论文的图2；否则，请参见图2。领导人选举的全部逻辑分布在图中的多个部分

14、不要忘记实现GetState（）

15、当测试人员永久关闭实例时，它会调用您的Raft的rf.Kill（）。您可以检查是否 杀（）被调用使用rf.killed（） 。
您可能希望在所有循环中都这样做，以避免死掉的Raft实例打印出混乱的消息

16、调试代码的一种好方法是在对等方发送或接收消息时插入打印语句，
然后使用go test -run 2A> out将输出收集到文件中 。
然后，通过研究out文件中的消息跟踪，可以确定实现偏离所需协议的位置。
您可能会发现util.go中的DPrintf 对调试各种问题时打开和关闭打印很有用

17、Go RPC仅发送名称以大写字母开头的结构字段。
子结构还必须具有大写的字段名称（例如，数组中的日志记录的字段）。
该labgob包会警告你这一点; 不要忽略警告

18、使用go test -race检查您的代码，并修复它报告的所有问题

在提交第2A部分之前，请确保您通过了2A测试，以便您看到类似以下内容的内容
$ go test -run 2A
测试（2A）：初选...
  ...通过-4.0 3 32 9170 0
测试（2A）：网络故障后选择...
  ...通过-6.1 3 70 13895 0
通过
好筏10.187s
$

每个“通过”行均包含五个数字；这些是测试花费的时间（以秒为单位），Raft对等体的数量（通常为3或5），
测试期间发送的RPC数量，RPC消息中的字节总数以及Raft记录的日志数量报告已提交。
您的电话号码将与此处显示的号码不同。您可以根据需要忽略这些数字，
但是它们可以帮助您理智地检查实现发送的RPC的数目。
对于所有实验2、3和4，如果所有测试（go test）花费的时间超过600秒，
或者单个测试花费的时间超过120秒，则评分脚本将使您的解决方案失败。