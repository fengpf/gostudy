筏结构建议

Raft实例必须处理外部事件的到来
（Start（）调用，AppendEntries和RequestVote RPC以及RPC答复），
并且必须执行定期任务（选举和心跳）。
有很多方法可以构建Raft代码来管理这些代码
活动；本文档概述了一些想法。

每个Raft实例都有一堆状态（日志，当前索引，
＆c）必须根据并发事件而更新
goroutines。Go文档指出，goroutines可以
使用共享数据结构和锁直接执行更新，
或通过在通道上传递消息。经验表明，对于木筏
使用共享数据和锁最简单。

一个Raft实例有两个时间驱动的活动：领导者必须发送
心跳，如果有太多时间，其他人必须开始选举
自从听到领导的声音以来就过去了。最好是开车
这些活动中有专门的长期运行的goroutine，
而不是将多个活动组合到一个goroutine中。

选举超时的管理是
头疼。也许最简单的计划是在
筏结构，包含对等方从
领导，并定期进行选举超时检查
查看此后的时间是否大于超时时间。
最简单的方法是使用time.Sleep（）和一个常量参数
进行定期检查。不要使用time.Ticker和time.Timer;
他们很难正确使用。

您将需要一个单独的长期运行的goroutine来发送
在applyCh上按顺序提交了日志条目。必须分开
因为发送applyCh会阻塞；它必须是一个
goroutine，因为否则可能很难确保您发送日志
条目以日志顺序排列。提升commitIndex的代码将需要
踢出应用goroutine; 这可能是最容易使用的条件
变量（转到sync.Cond）。

每个RPC可能应该以自己的方式发送（并处理其回复）
goroutine，有两个原因：使得无法访问的同伴不会延迟
收集大多数答复，以便心跳和
选举计时器可以一直计时。最容易做到的
在同一goroutine中进行RPC回复处理，而不是发送
通过渠道回复信息。

请记住，网络可能会延迟RPC和RPC答复，以及何时
您发送并发的RPC，网络可以重新排序请求，
回覆。图2很好地指出了RPC的位置
处理程序必须对此谨慎（例如，RPC处理程序应
忽略带有旧术语的RPC）。图2并非总是关于RPC的明确信息
回复处理。领导在处理时必须小心
回覆 它必须检查自发送
RPC，并且必须考虑并发响应的可能性
到同一关注者的RPC已更改了领导者的状态（例如
nextIndex）。