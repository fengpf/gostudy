

### 两种算法的区别

两者主要区别在于“漏桶算法”能够强行限制数据的传输速率，
而“令牌桶算法”在能够限制数据的平均传输速率外，还允许某种程度的突发传输。在“令牌桶算法”中，
只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，所以它适合于具有突发特性的流量。

### 漏桶算法
//思路：水(请求)先进入桶里，漏桶以一定的速率出水
//当水流速度过大会直接溢出，可以看出漏桶算法能限制数据的传输速率

//在某些情况下，漏桶算法不能够有效地使用网络资源。因为漏桶的漏出速率是固定的参数，
//所以即使网络中不存在资源冲突（没有发生拥塞），漏桶算法也不能使某一个单独的流突发到端口速率。
//因此，漏桶算法对于存在突发特性的流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。
//通常，漏桶算法与令牌桶算法可以结合起来为网络流量提供更大的控制。


### 令牌桶算法：
//
//对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这
//时候漏桶算法可能就不合适了，令牌桶算法更为适合。
//如图2所示，令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，
//则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。

//令牌桶算法的基本过程如下：
//
//　　假如用户配置的平均发送速率为r，则每隔1/r秒一个令牌被加入到桶中；
//
//　　假设桶最多可以存发b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃；
//
//　　当一个n个字节的数据包到达时，就从令牌桶中删除n个令牌，并且数据包被发送到网络；
//
//　　如果令牌桶中少于n个令牌，那么不会删除令牌，并且认为这个数据包在流量限制之外；
//
//　　算法允许最长b个字节的突发，但从长期运行结果看，数据包的速率被限制成常量r。对于在流量限制外的数据包可以以不同的方式处理：
//
//　　它们可以被丢弃；
//
//　　它们可以排放在队列中以便当令牌桶中累积了足够多的令牌时再传输；
//
//　　它们可以继续发送，但需要做特殊标记，网络过载的时候将这些特殊标记的包丢弃。

